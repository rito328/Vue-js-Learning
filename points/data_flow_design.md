# データフローの設計

## 単方向データフロー

### カウンターアプリ例）

```
[ 状態 ] ──────> [ ビュー ]  
　↑　　　　　　　　　 　┃   
　└──[ 更新処理 ]   <─┘
```
* 「状態」は、カウンターアプリを表現する為に必要なデータを保持
* 「ビュー」は、状態の値に応じてカウンターアプリの見た目を構築
* 「更新処理」は、ビューから呼び出され、状態を更新


## 双方向データフロー
```
[ 状態 ] <─────> [ ビュー ]
```
* 状態更新のロジックがコンポーネントの中に書かれている為、同じような更新を別のコンポーネントから行いたい場合に再利用する事が難しくなる
* 更新処理に変更を加えたい場合、変更を行う必要のある場所が様々なコンポーネントに依存する事になる


# データフロー設計において頻出するデザインパターン
* 信頼できる唯一の情報源（Single Source of Truth）
* 「状態の取得・更新」のカプセル化
* 単方向データフロー

## 信頼できる唯一の情報源（Single Source of Truth）
管理する対象のデータを一箇所に集約することで管理を容易にすることを目的とした設計パターン
* どのコンポーネントも同一のデータを参照するため、データや表示の不整合が発生しづらい
* 複数のデータを組み合わせた処理を比較的容易に実装できる
* データの変更のログ出力、現在のデータの確認などの開発に便利なツールを作りやすい

## 「状態の取得・更新」のカプセル化
状態の取得・更新のカプセ柄を行う事で、状態管理のコストを下げる事ができる。
* 状態の取得・更新のロジックを様々な場所から利用できる
* 詳細な実装をビューから隠蔽する事で、データ構造や取得、更新処理の変更の影響範囲を小さくする
* デバッグ時に確認する場所が限られるため、デバッグが容易になる

### 例）カウンターアプリの例  
更新処理をstore内に記述することでカプセル化 -> コンポーネントからは具体的にどのような実装がされているかは隠されている

# 単方向データフロー
データフローを単方向にすることで、状態の取得・更新のコードが簡潔になる  
データが単方向でない場合、データの取得と更新の両方を同時に行える事になるのでより複雑な処理になり理解が難しくなる
* データを取得しつつ更新するといったような事ができなくなり、実装がデバッグが単純になる
* データを取得・更新する為に何をするかの選択肢が絞られて、理解が容易なコードを書きやすい